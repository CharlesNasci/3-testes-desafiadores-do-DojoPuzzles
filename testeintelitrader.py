# -*- coding: utf-8 -*-
"""TesteIntelitrader.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H6o4-IZaXf8i3kY6RbdKh9AcqNra9bsY

Você está resolvendo este problema.
Este problema foi utilizado em 1222 Dojo(s).

Jokenpo é uma brincadeira japonesa, onde dois jogadores escolhem um dentre três possíveis itens: Pedra, Papel ou Tesoura.

O objetivo é fazer um juiz de Jokenpo que dada a jogada dos dois jogadores informa o resultado da partida.

As regras são as seguintes:

Pedra empata com Pedra e ganha de Tesoura
Tesoura empata com Tesoura e ganha de Papel
Papel empata com Papel e ganha de Pedra
"""

#Jokenpô 
if __name__ == "__main__": 
     jokenpo()
from random import randint
import time

def jokenpo():
    player = int(input('Digite 1 para PEDRA \nDigite 2 para PAPEL \nDigite 3 para TESOURA\n'))
    machine = randint(1, 3)

    if player == 1:
        print('Jo')
        time.sleep(1)
        print('Ken')
        time.sleep(1) 
        print('Pô!')
        print('Você escolheu pedra.')
        if machine == 1:
            print('A máquina escolheu Pedra, vocês empataram.')
        elif machine == 2:
            print('A máquina escolheu Papel, você perdeu.')
        elif machine == 3:
            print('A máquina escolheu Tesoura, você ganhou')
    if player == 2:
        print('Jo')
        time.sleep(1)
        print('Ken')
        time.sleep(1)
        print('Pô!')
        print('Você escolheu papel.')
        if machine == 1:
            print('A máquina escolheu Pedra, você ganhou.')
        elif machine == 2:
            print('A máquina escolheu Papel, vocês empataram.')
        elif machine == 3:
            print('A máquina escolheu Tesoura, você perdeu.')
    if player == 3:
        print('Jo')
        time.sleep(1)
        print('Ken')
        time.sleep(1)
        print('Pô!')
        print('Você escolheu tesoura')
        if machine == 1:
            print('A máquina escolheu Pedra, você perdeu.')
        elif machine == 2:
            print('A máquina escolheu Papel, você ganhou.')
        elif machine == 3:
            print('A máquina escolheu Tesoura, vocês empataram')

"""Distribuição de Mictórios

Este problema foi utilizado em 252 Dojo(s).

Um problema enfrentado pelos homens no uso de mictórios em banheiros públicos é o constrangimento causado por outro homem urinando no mictório ao lado. Uma situação contrangedora é definida quando dois "mijões" deveriam ocupar mictórios adjacentes.

Dada uma quantidade de mictórios em um banheiro e a ocupação inicial deles (informando em qual deles já existe um "mijão"), determine quantos "mijões" ainda podem usar os mictórios e qual a posição deles antes para que não ocorra uma situação constrangedora.
"""

import unittest



def esta_vazio(mijoes, i):
    li = max(i-1, 0)
    ls = min(i+2, len(mijoes))
    
    return True if mijoes[li:ls] == (ls-li)*'o' else False

    #if i == 0 and mijoes[i:i+2] == 'oo':
    #    return True
    #elif i == len(mijoes)-1 and mijoes[i-1:i+1] == 'oo':
    #    return True
    #elif mijoes[i-1:i+2] == 'ooo':
    #    return True
    #return False

def mictorio(mijoes):
    mictorios_livres = []
    if mijoes is None:
       return []
    
    #if mijoes == 'o':
    #    return [0]
          
    i=0
    #for i in range(len(mijoes)):
    while(i < len(mijoes)):
        if esta_vazio(mijoes, i):
            mictorios_livres.append(i)
            i += 1
        i += 1
           
    return mictorios_livres

class MictorioTest(unittest.TestCase):
    def test_xoo(self):
        self.assertEqual([2], mictorio('xoo'))
    def test_xoxo(self):
        self.assertEqual([], mictorio('xoxo'))
    def test_x(self):
        self.assertEqual([], mictorio('x'))
    def test_o(self):
        self.assertEqual([0], mictorio('o'))
    def test_xoooo(self):
        self.assertEqual([2,4], mictorio('xoooo'))
    def test_ooxooxoooxxoo(self):
        self.assertEqual([0,7,12], mictorio('ooxooxoooxxoo'))
    def test_ooooooooo(self):
        self.assertEqual([0,2,4,6,8], mictorio('ooooooooo'))
    def test_oxoxoxoxo(self):
        self.assertEqual([], mictorio('oxoxoxoxo'))
    def test_oxoxoxoxoo(self):
        self.assertEqual([9], mictorio('oxoxoxoxoo'))
    def test_null(self):
        self.assertEqual([], mictorio(None))

if __name__ == '__main__':
    unittest.main()

"""Descubra o assassino

Este problema foi utilizado em 338 Dojo(s).

O empresário Bill G. Ates foi assassinado e o corpo dele foi deixado na frente da delegacia de polícia. O detetive Lin Ust Orvalds foi escolhido para investigar este caso. Após uma série de investigações, ele organizou uma lista com prováveis assassinos, os locais do crime e quais armas poderiam ter sido utilizadas.

Suspeitos:

Charles B. Abbage
Donald Duck Knuth
Ada L. Ovelace
Alan T. Uring
Ivar J. Acobson
Ras Mus Ler Dorf
Locais:

Redmond
Palo Alto
San Francisco
Tokio
Restaurante no Fim do Universo
São Paulo
Cupertino
Helsinki
Maida Vale
Toronto
Armas:

Peixeira
DynaTAC 8000X (o primeiro aparelho celular do mundo)
Trezoitão
Trebuchet
Maça
Gládio
Uma testemunha foi encontrada, mas ela só consegue responder se Lin fornecer uma teoria. Para cada teoria ele "chuta" um assassino, um local e uma arma. A testemunha então responde com um número. Se a teoria estiver correta (assassino, local e arma corretos), ela responde 0. Se a teoria está errada, um valor 1,2 ou 3 é retornado. 1 indica que o assassiona está incorreto; 2 indica que o local está incorreto; 3 indica que a arma está incorreta. Se mais de uma suposição está incorreta, ela retorna um valor arbitrário entre as que estão incorretos (isso é totalmente aleatório).

Por exemplo, se o assassino for Donald Duck Knuth usando um trezoitão em Tokio:

Teoria: 1, 1, 1
Retorno: 1, ou 2, ou 3 (todos estão incorretos) 

Teoria: 3, 1, 3
Retorno: 1, ou 3 (somente o local está correto)

Teoria: 5, 3, 4
Retorno: 1 (somente o assassino está incorreto)

Teoria: 2, 3, 4
Retorno: 0 (todos corretos, você solucionou o caso)

Você precisa desenvolver um programa que tente resolver o problema. Inicialmente não se preocupe no número de tentativas necessário para encontrar a solução. Depois tente melhorar a maneira com que as teorias são testadas para que Lin encontre a solução do problema no menor número de tentativas.
"""

import unittest
import random
from testemunha import Testemunha
from detetive import Detetive


suspeitos = ['Charles B. Abbage', 'Donald Duck Knuth', 'Ada L. Ovelace', 'Alan T. Uring', 'Ivar J. Acobson', 'Ras Mus Ler Dorf']
locais = ['Redmond', 'Palo Alto', 'San Francisco', 'Tokio', 'Restaurante no Fim do Universo', 'São Paulo', 'Cupertino', 'Helsinki', 'Maida Vale', 'Toronto']
armas =['Peixeira', 'DynaTAC 8000X (o primeiro aparelho celular do mundo)', 'Trezoitão', 'Trebuchet', 'Maça', 'Gládio']

class TestemunhaTest(unittest.TestCase):
    def setUp(self):
        self.crime = [1, 2, 1]
        self.testemunha = Testemunha(self.crime[0], self.crime[1], self.crime[2])

    def selecionarSuspeitoErrado(self):
        suspeito_errado = self.crime[0]
        while suspeito_errado == self.crime[0]:
            suspeito_errado = random.choice(range(0,len(suspeitos)))
        return suspeito_errado

    def selecionarLocalErrado(self ):
        local_errado = self.crime[1]
        while local_errado == self.crime[1]:
            local_errado = random.choice(range(0,len(locais)))
        return local_errado

    def selecionarArmaErrada(self):
        arma_errada = self.crime[2]
        while arma_errada == self.crime[2]:
            arma_erraada = random.choice(range(0,len(armas)))
        return arma_errada
    
    def test_hipoteseTodaErrada(self):
        for i in range(0,100):
            suspeito_errado = self.selecionarSuspeitoErrado
            local_errado = self.selecionarLocalErrado
            arma_errada = self.selecionarArmaErrada
            self.assertIn(self.testemunha.foi(suspeito_errado, local_errado, arma_errada), [1,2,3])
        
    def test_hipoteseSuspeitoCerto(self):
        suspeito = self.crime[0]
        for i in range(0,100):
            local_errado = self.selecionarLocalErrado
            arma_errada = self.selecionarArmaErrada
            testemunho = self.testemunha.foi(suspeito, local_errado, arma_errada)
            self.assertIn(testemunho, [2,3])
            self.assertNotEqual(1, testemunho)

    def test_hipoteseLocalCerto(self):
        local = self.crime[1]
        for i in range(0,100):
            suspeito_errado = self.selecionarSuspeitoErrado
            arma_errada = self.selecionarArmaErrada
            testemunho = self.testemunha.foi(suspeito_errado, local, arma_errada)
            self.assertIn(testemunho, [1,3])
            self.assertNotEqual(2, testemunho)

    def test_hipoteseArmaCerta(self):
        arma = self.crime[2]
        for i in range(0,100):
            suspeito_errado = self.selecionarSuspeitoErrado
            local_errado = self.selecionarLocalErrado
            testemunho = self.testemunha.foi(suspeito_errado, local_errado, arma)
            self.assertIn(testemunho, [1,2])
            self.assertNotEqual(3, testemunho) 

    def test_hipoteseSuspeitoELocalCertos(self):
        suspeito = self.crime[0]
        local = self.crime[1]
        for i in range(0,100):
            arma_errada = self.selecionarArmaErrada
            testemunho = self.testemunha.foi(suspeito, local, arma_errada)
            self.assertEqual(3, testemunho) 
    
    def test_hipoteseSuspeitoEArmaCertos(self):
        suspeito = self.crime[0]
        arma = self.crime[2]
        for i in range(0,100):
            local_errado = self.selecionarLocalErrado
            testemunho = self.testemunha.foi(suspeito, local_errado, arma)
            self.assertEqual(2, testemunho)

    def test_hipoteseLocalEArmaCertos(self):
        local = self.crime[1]
        arma = self.crime[2]
        for i in range(0,100):
            suspeito_errado = self.selecionarSuspeitoErrado
            testemunho = self.testemunha.foi(suspeito_errado, local, arma)
            self.assertEqual(1, testemunho)

    def test_hipoteseCerta(self):
        suspeito = self.crime[0]
        local = self.crime[1]
        arma = self.crime[2]
        self.assertEqual(0, self.testemunha.foi(suspeito, local, arma))


class DetetiveTest(unittest.TestCase):
    def setUp(self):
        self.crime = [1, 2, 1]
        self.testemunha = Testemunha(self.crime[0], self.crime[1], self.crime[2])
        self.detetive = Detetive(self.testemunha, suspeitos, locais, armas)

    def test_investigacao(self):
        self.assertEqual(self.crime, self.detetive.Investigar())

    def test_testemunhaMentirosa(self):
        crime = [ -1, -1, -1]
        testemunha = Testemunha(crime[0], crime[1], crime[2])
        detetive = Detetive(testemunha, suspeitos, locais, armas)
        self.assertEqual(False, detetive.Investigar())

if __name__ == '__main__':
    unittest.main()

import testemunha

class Detetive(object):
   """Classe detetive que vai investigar quem foi o assassino"""
   def __init__(self, testemunha, suspeitos, locais, armas):
      self.testemunha = testemunha
      self.suspeitos = suspeitos
      self.locais = locais
      self.armas = armas
      
   def Investigar(self):
      hipotese =  -1
      suspeito_corrente = 0
      local_corrente       = 0
      arma_corrente      = 0

      while(hipotese != 0 and len(self.suspeitos) > suspeito_corrente and len(self.locais) > local_corrente and len(self.armas) > arma_corrente):
         hipotese = self.Hipotese(suspeito_corrente, local_corrente, arma_corrente)
         if hipotese == 1:
            suspeito_corrente += 1
         elif  hipotese == 2:
            local_corrente += 1
         elif hipotese == 3:
            arma_corrente +=1

      if hipotese == 0:   
         print "Crime resolvido: {0} assassinou a vitima usando {1} em {2}".format( \
            self.suspeitos[suspeito_corrente], \
            self.armas[arma_corrente], \
            self.locais[local_corrente])
         return [suspeito_corrente, local_corrente, arma_corrente]
      else:
         print "Prendam a testemunha por falso testemunho!"
         return False

   def Hipotese(self, suspeito, local, arma):
      print "Testemunha, Foi {0} usando {1} em {2}?".format( \
         self.suspeitos[suspeito], \
         self.armas[arma], \
         self.locais[local])
      return self.testemunha.foi(suspeito, local, arma)

import random

class Testemunha(object):
   """Classe que testemunhou o assassinato, vai informar se a hipotese do detetive esta certa"""
   def __init__(self, assassino, local, arma):
      self.assassino = assassino
      self.local = local
      self.arma = arma
   
   def foi(self, assassino, local, arma):
    acertos = []
    if assassino != self.assassino:
        acertos.append(1)
    if local != self.local:
        acertos.append(2)
    if arma != self.arma:
        acertos.append(3)
    if assassino == self.assassino and local == self.local and arma == self.arma:
        acertos.append(0)

    return random.choice(acertos)